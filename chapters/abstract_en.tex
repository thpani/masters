\chapter*{Abstract}

Loop statements are an indispensable construct to express repetition in imperative programming languages. At the same time, their ability to express indefinite iteration entails undecidable problems, as famously demonstrated by Turing's work on the halting problem. Due to these theoretic limitations, efficacy of a termination procedure can only be demonstrated on practical problems -- by Rice's theorem the same goes for any automated program analysis. Even though we have techniques to tackle some but by far not all decidable cases, so far no established notion of difficulty with regard to handling loops exists in the scientific community. Consequently, the occurrence of such "simple" and "difficult" loops in practice has not yet been investigated.

We propose to conduct a systematic study that describes classes of loops and empirically determines difficulty of automated program analysis for each class. To arrive at this classification, we draw on a recent direction in software verification: Instead of treating programs merely as mathematical objects, we also consider them as human artifacts that carry important information directed at human readers of the program. This engineering information should be leveraged for automated program analysis, but is usually provided informally (e.g.\ as comments) or implicitly (e.g.\ as patterns followed by programmers). Thus, a formally sound framework to extract such information about loops is needed.

A direct application of this study is the empiric evaluation of automated program analysis: As discussed, such an evaluation is of central importance to establish academic merit as well as applicability to the software engineering domain. However, as we show, experimental results are currently insufficiently comparable, due to the wide range of benchmark programs used. We propose the introduction of \emph{benchmark metrics}, such as the number of "simple" loops mentioned above, as a way to characterize benchmarks and achieve better comparability.

Motivated by the state of the art, this thesis conducts a systematic study of loops in C programs to classify loops based on the difficulty of automated program analysis. To arrive at our classification, we leverage the program's structure as imposed by the programmer: We introduce the class \emph{syntactically terminating loops}, a common engineering pattern for which termination proofs can be obtained using minimal information, and describe how to determine class membership. Subsequently, we derive the family of \emph{simple loops} by systematically weakening syntactically terminating loops along different dimensions, which allows us to describe a majority of loops in our benchmarks while still capturing syntactic termination criteria well. Finally, we present our tool \sloopy{} and compare the identified loop classes with results experimentally obtained from \loopus{}, a tool to compute symbolic loop bounds. Thus we show that simple loops indeed capture the difficulty of automated program analysis.
