In this work we have introduced a pattern-based approach to classify loops with respect to their difficulty for automated program analysis and empirically shown that the respective classes indeed capture this difficulty. There are a number of research directions that naturally build on this work and that will benefit from further investigation:

\begin{description}
    \item[Extension of simple loops to data structures.] The simple loop classes presented in this thesis cover a majority of the loops in our benchmarks. However, these classes are solely based on integer and pointer arithmetic, i.e.\ they represent loops that iterate a range of integers or the contents of an array. It is still interesting to investigate other types of iteration, especially of data structures such as null-terminated lists, to find termination criteria similar to syntactically terminating loops and subsequently derive approximations as we did for simple loops. Clearly, the occurrence of these classes in practical examples should be studied in a fashion similar to this work.
    \item[Quality assurance in software engineering.] While many methods such as testing or code reviews augment the software engineering process, in many settings software engineering is subject to economic constraints. A notion of difficulty can be used to allocate resources to the more complex cases. Additionally, application of automated program analysis is usually subject to high resource utilization, e.g.\ CPU time or memory consumption. If access to these resources is restricted, it makes sense to allocate them in a way where most impact is expected. In this context, it is also interesting to investigate applicability of this work as a classic software metric, i.e.\ to indicate likely defects, for example by measuring the number of non-simple loops in a module.
    \item[Internal heuristic for automated program analysis.] Similar to the previous point, but at a lower level, we believe that a systematic treatment of loops can yield results to guide formal methods-based tools internally, e.g.\ as a heuristic for selecting appropriate abstraction functions \cite{DBLP:journals/corr/abs-1305-6745}, as input to invariant generation \cite{DBLP:conf/fase/KovacsV09}, or for preselecting loops that should benefit from additional preprocessing such as loop acceleration \cite{DBLP:conf/cav/KroeningLW13}.
    \item[Programming language design.] Programming languages should ideally be designed to make the software engineering process efficient. To improve programming language design, it is essential to study how programmers employ existing language constructs. Studying the applicability of our results to programming language design, and making concrete suggestions based on this data opens a further research direction in addition to the contributions to program analysis we have discussed in this work.
\end{description}
